
Наше решение этой проблемы — использовать высоко итеративный процесс проектирования. 

Я начинаю с написания кода макета пользовательской земли. Этот API пока не существует, но я продолжаю писать макет кода, пока он меня не устроит. Я пишу код для создания всех ресурсов, которые мне нужны для рендеринга, текстур, шейдеров, буферов и т. д., а затем пишу небольшой цикл отрисовки с использованием этих ресурсов. Цикл отрисовки вызывается несколько раз, при этом некоторые ресурсы мутируют для реализации анимации. Важно заранее спроектировать как динамические, так и статические пути данных.

Как только я буду доволен первой итерацией кода пользовательской земли, я пишу для него API макета платформы. На данный момент это просто пустой API. Реализации бэкэнда нет. Но он позволяет мне начать использовать компилятор для проверки синтаксиса и автодополнения. Теперь я действительно могу начать экспериментировать с API, чтобы увидеть, насколько он удобен в использовании.

Затем я проведу проверку производительности для всего кода пользовательской земли. Я хорошо понимаю, как работают все API платформы, поэтому я думаю, какой тип реализации каждого вызова API потребуется в бэкендах Vulkan, Metal и WebGPU. Если реализация тривиальна, то все в порядке. Если реализация требует дополнительных копий данных, поиска в хэш-картах, выделения памяти или других дорогостоящих операций, то я отбрасываю этот дизайн и переписываю эту часть API, чтобы она была более эффективной. Как вы помните, наша цель — быть такими же быстрыми, как оптимизированный вручную DX12 в каждом отдельном случае. Мы не сможем этого сделать, если наш API не будет идеально соответствовать базовому аппаратному API.
