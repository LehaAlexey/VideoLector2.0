
Одной из наших главных целей было сделать API таким же простым в использовании, как DX11. Для этого нам нужно объединить вспомогательные данные в наши структуры данных в пулах. В Vulkan дескриптор VkTexture ничего не знает о себе, что раздражает, если вы пытаетесь написать свой код рендеринга на чистом Vulkan. Мы хотим, чтобы наша структура текстуры знала свой размер, формат, указатель данных для записи, распределитель для удаления и так далее. 

Эти вспомогательные данные требуются для низкочастотных задач, таких как изменение ресурса и удаление ресурса. Поскольку наш принцип проектирования заключается в разделении изменений ресурсов от рисования, мы получаем доступ к этим данным только при изменении или удалении ресурса. Это означает, что размещение вспомогательных данных в той же структуре, что и данные, необходимые в цикле горячей отрисовки, неэффективно с точки зрения кэширования. Цикл отрисовки будет загружать данные в L1$, которые не используются. Я ненавижу компромиссы между производительностью и удобством использования. 

Наше решение этой проблемы — использовать макет SoA внутри пулов. Мы определяем, какие данные требуются в каждом кадре в циклах горячей отрисовки, и помещаем эти данные в одну структуру, а оставшиеся низкочастотные вспомогательные данные — в другую структуру. Теперь в пуле два массива данных вместо одного. Мы можем использовать тот же индекс массива в дескрипторе для доступа к любому из массивов данных (или к обоим). Таким образом, нам нужно загружать горячие данные в кэши только в цикле отрисовки, критическом для производительности.
